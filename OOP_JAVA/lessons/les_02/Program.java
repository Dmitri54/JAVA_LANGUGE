/**
 * Урок 2. Принципы ООП Абстракция и интерфейсы. 
 * Пример проектирования
 * =====================================================================================================
 * План занятия:
 * 1. Введение
 * 2. Абстракция
 * 3. Абстрактный класс
 * 4. Абстрактный метод
 * 5. Интерфейс
 * 6. Примеры
 * 7. Итоги
 * ------------------------------------------------------------------------------------------------------
 * ● Инкапсуляция
 * ● Наследование
 * ● Полиморфизм
 * ● Абстракция
 * ● * переиспользование кода
 * ● * отправка сообщений
 * -----------------------------------------------------------------------------------------------------
 * Абстракция – это свойство системы, позволяющее описать общие характеристики базового класса
 * для всех его производных классов, а наполнение деталями предоставляется каждому из этих классов.
 * 
 * В абстрактном классе определяются лишь общие поля и характер методов, которые должны быть конкретно
 * реализованы в производных классах, а не в самом базовом классе.
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 */

//  public abstract class Model {
//     public abstract void Method();
//    }
    
/**
 * 
 */


package OOP_JAVA.lessons.les_02;

public class Program {

    // static void A(){
    //     System.out.println("A()");
    // }
    // public static void main(String[] args) {

    //    A(); // Вызов статического метода.
// ---------------------------------------------------------------------------------------------------
/*
 * static - позволяет обращаться к статическим членам через имя типа.
 * Всоответсвии с модификаторами доступа, которые я знаю:
 * public - доступен откуда хочешь;
 * protected - доступен в текущем классе и во всех классах наследников.
 * private - доступен в только внутри текущем класса.
 * ----------------------------------------------------------------------------------------------------
 * Если не писать слово static
 */

    
    void A(){
        System.out.println("A()");
    }
    public static void main(String[] args) {

        Program prog = new Program(); // Создал экземпяр класса Program
        prog.A(); // и через нео вызываю экземплярный метод.

//------------------------------------------------------------------------------------------------------    
    //    Foo f1 = new Foo();
    //    f1.value = 123;
    // //    System.out.println(f1.value);

    //    f1.printCount(); 

    // //    Foo.count = 123000;

    //    Foo f2 = new Foo();
    //    f2.value = 222;
    // //    System.out.println(f2.value);
    //    f2.printCount();

    //    Foo f3 = new Foo();
    //    f3.value = 444;
    // //    System.out.println(f3.value);
    //    f3.printCount();
    }
}

/** 
 * Далее разбор кода игры
 * Ex001 - пользователь может создать Героя базового класса BaseHero - это нужно спрятать, 
 * т.к. не может существовать.
 * ------------------------------------------------------------------------------------------------------
 * Ex002 - исправил. Добавил слово abstract в описание класса BaseHero. Добавил в этот класс абстрактрый
 * метод public abstract void die(); - так можно делать, когда точно знаю, что такой метод будет описан, а 
 * мне нужно сейчас описать вызов этого метода в другом методе класса.
 * ------------------------------------------------------------------------------------------------------
 * Ex003 - в некоторых случаях нужно создавать более сложную иерархию. К примеру у меня два клана.
 * Как они создаются и как обеспечить их взоимодействие между собой. Есть стандартные три персонажа и ещё
 * четыре персонажа.
 * -------------------------------------------------------------------------------------------------------
 * Ex004 - на фото, есть базовый тип BaseHero, есть производный тип Druid, от которого так же 
 * производиться Dwarf. 
 * Ситуация, при которой я буду уходить от BaseHero уходить в Druid, наз. DOWNCAST.
 * Когда мне нужно подняться на иерархию выше, такое наз. UPCAST. 
 * Важно понимать в каком порядке вызываются конструкторы в такох больших иерархиях.
 * Убрал из кода BaseHero всё лишнее оставив только конструктор по умолчанию и конструктор с двумя 
 * аргументами. Далее есть Druid, который наследуется из BaseHero. Так же есть Dwarf, наследник Druid.
 * ----------------------------------------------------------------------------------------------------
 * ОБРАТИ ВНИМАНИЕ !
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * Как реализованы конструкторы?
 * ?????????????????????????????????????????????????????????????????????????????????????????????????????
 * BaseHero конструктор с двумя аргументами - есть в нем базовый вызов конструктора BaseHero.
 * Далее внутри конструктора по умолчанию происходит вызов текущего конструктора с двумя аргументами
 * и при печати я делаю пометку, что в данный момент было вызвано.
 * Далее Druid. У него есть конструктор с двумя аргументами, который вызывает конструктор базового класса
 * (super(name, hp);) и дальше делаю пометку ("Вызван Druid").
 * -----------------------------------------------------------------------------------------------------
 * Для чего может потребоваться такая иерархия??????????????????????????????????????????????????????????
 * -----------------------------------------------------------------------------------------------------
 * Пример: у меня есть базовый класс BaseHero и класс Druid наследник.
 * В BaseHero мне нужно указать поле (int hp;) и в методе нужно прописать, что это hp равно hp 
 * этого конструктора (this.hp = hp;). 
 * На следующем этапе создаю Druid, у которого есть поле (int mp;), дописываю конструктор так, чтобы я мог 
 * передовать манну, для этого персонажа, присваиваю (this.mp = mp;).
 * ВАЖНО!
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * Сначало я инициализирую, то что является в базовом классе, все параметры или когда вношу изменения.
 * Дальше, перехожу к конкретному экземпляру Druid и у него конкретные поля свойств.
 * -----------------------------------------------------------------------------------------------------
 * Далее есть Dwarf наследники Druid. Важно когда я пришу (super();) в Dwarf, базовым классом является 
 * Druid и через super я буду обращаться к этому типу. 
 * Program - далее иерархия вызова конструкторов.
 * -----------------------------------------------------------------------------------------------------
 * F12 - кнопка позволяет переходить между связанным между собой кодом.
 * ------------------------------------------------------------------------------------------------------
 */ 

 /** 
 * Абстракция – это свойство системы, позволяющее описать общие характеристики базового класса
 * для всех его производных классов, а наполнение деталями предоставляется каждому из этих классов.
 * В абстрактном классе определяются лишь общие поля и характер методов, которые должны быть
 * конкретно реализованы в производных классах, а не в самом базовом классе.
 * 
 * public abstract class Model {
 *  public abstract void Method();
 * }
 * ---------------------------------------------------------------------------------------------------
 * Интерфейс.
 * interface предназначен для описания исключительно общего поведения сущностей.
 * Частный случай: для гарантии, реализации некоторого поведения.
 * 
 * Интерфейс – это частный случай класса.
 * Он представляет собой полностью абстрактный класс с абстрактными членами.
 * ---------------------------------------------------------------------------------------------------
 * * Аналогичен абстрактному классу со всеми абстрактными методами, 
 *   но допускается множественное наследование.
 * 
 * * расширение поведения
 * 
 * * что я могу делать
 * ---------------------------------------------------------------------------------------------------
 * Ex005 - более сложная иерархия отбражена в фото и коде.
 * v1 - решение без интерфейса.
 * Что если один персонаж может атаковать и лечить, прописывать каждому метод долго, для этого есть интерфейс.
 * v2 - решение с интерфейсом. Комментарии в файле Shaman.java. Создание героя типа бог God.java
 * ====================================================================================================
 * Задача: 
 * У меня есть текстовый редактор позволяющий сохранять данные в разных форматах.
 * Реализовать функционал позволяющий взависимости от нажатия нужной кнопки сохранять в нужном формате.
 * Ex006 - решение.
 * Важно понимать структуру данного распределения кода, сами методы, то как они будут сохранять можно 
 * написать потом.
 * Pdf.java - пример заготовки.
 */
