/**
 * Урок 6. Хранение и обработка данных.
 * ч3: множество коллекций Set.
 * ==================================================================================================
 * Разбор Д/з 
 * 5. *Увеличить количество элементов до 1000 случайными ключами и общей строкой.
 * Чтобы HashMap работал быстро нужно избезать образования большого количества корзин (LinkedList-ов).
 * Поэтому нужно генерировать случайное число так, чтобы hash был силино отличным друг от друга.
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * 
 * Character.getName(int ...); У класса обертки Character есть метод .getName() - это статический имена ему 
 * ни чего не надо создавать, ему передаю цифру, а он возвращает строковое значение имя этой цифры, так можно 
 * строки генерировать. На выходе я буду считать цифры от 0 до 1000, с другой стороны этот метод будет 
 * возвращать разные строки, у которых будут разные hash-и. Они будут предсказуемыми, но это решит проблему
 * возникновения больших корзин, т.к. из-за этого снизится скорость HashMap, если Java до 8 ВЕРСИИ.
 * ======================================================================================================
 * Задание 1.
 * Смоделировать добавление элемента в Set, но Set использовать нельзя.
 * Set - внутри себя автоматически сортирует коллекцию.
 */

package seminars.sem_06;

import java.util.HashMap;

public class Program {
    public static void main(String[] args) {

        MySet mySet = new MySet(); // str - экземпляр класса MySet. 

        mySet.add(1);
        mySet.add(6);
        mySet.add(37);
        mySet.add(6); // Ключи не могут повторятся!
        System.out.println(mySet.toString()); // [1, 37, 6] 
        
        for (int i = 0; i < mySet.sizeMap(); i++) {
            System.out.println(mySet.getItem(i));
        }
    }    
}

class MySet {

    private HashMap<Integer, Object> map = new HashMap<>();

    private static final Object OBJ = new Object();
    
    public boolean add(Integer i) {
        return map.put(i, OBJ) != null? true: false; // Если он не равен 0, то false.
        // map.put(i, OBJ);
        // return true;
    }
    @Override // Это анатация, которая означает, что метод toString() уже где-то определен в Object (глобал).
// Override - это и есть переопределение. Теперь если я вызову метод toString(), то он будет делать то, что
// написано в методе, а не то, что написанов Object.
    public String toString() {
        return map.keySet().toString(); // Беру из map все ключи и перевожу в строку. 
    }

    public Integer sizeMap() { // Вернет размер map.
        return map.keySet().size();
    }

    public Integer getItem(Integer i) {
        return (Integer) map.keySet().toArray()[i]; 
    }
}

