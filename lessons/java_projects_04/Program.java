// Урок 4. Хранение и обработка данных ч1: приоритетные коллекции.
// =========================================================================================
/**
 * План занятия:
 * 1. Разобраться, зачем нужно столько коллекций и JCF.
 * 2. LinkedList и особенности работы с ним.
 * 3. Узнать о списках, как об абстрактной структуре.
 * 4. Проблемы работы со списками и массивами.
 * 5. Построение разных Queue и как в этом помогает JCF.
 * 6. Deque и логика использования этой коллекции.
 * 7. То, что мертво, умереть не может – Stack в контексте JCF.
 */
// ---------------------------------------------------------------------------------------------
/**
 * Зачем нужны разные коллекции?
 * ---------------------------------------------------------------------------------------------
 * 1. Способ обработки данных
 * 2. Решаемые задачи
 * ---------------------------------------------------------------------------------------------
 * LinkedList - коллекция.
 * Представляет собой двусвязный список (используя теорию алгоритмов).
 * Список – гибкая структура данных, позволяющая легко менять свой размер. 
 * Элементы доступны для вставки или удаления в любой позиции.
 * ----------------------------------------------------------------------------------------------
 * Пример:
 * При создании МАССИВА, имя его хранится в STACK, данные в HEAP последовательно друг за другом.
 * Чтобы узнать, что в ячейке, нужно пройти по массиву сначала.
 * При создании связного списка (ссылочный тип), имя храниться в STACK, данные в HEAP в хаотичном парядке.
 * Каждая яцейка этой памяти хранит в себе ссылку на следующую.
 * 
 * При добавлении данных в массив, может получиться, что ячейки памяти в этой области уже заполнены другой
 * программой и чтобы мне добавить один элемент в массив, нужно найти место в памяти под новый массив,
 * скопировать данные из старого в новый, заменить ссылку на эти данные, удалить старые данные и добавить 
 * новый элемент в массив. 
 * МИНУС: Это долго!!! --------------------------------------------------------------------------------
 * Примерно, то же самое происходит при удалении одного элемента из массива.
 * Удаляю элемент, сдвигаю все за ним на свободную позицию, ищу место в памяти под новый массив, копирую 
 * данные в новый массив, заменяю ссылку и удаляю старый массив.
 */
/**
 * LinkedList. Список.
 * Чем такой способ организации лучше? Или хуже?
 * При дабавлении нового элемента в список ссылочного типа: свободное место в памяти, записываю значение, 
 * меняю ссылку с того элемента, которой стоит перед тем, что нужно было заменить на новые данные и передаю
 * в эту эе яцейку ссылку на следующий элемент массива, которая была взята из удаляемого элемента.
 * Удаление происходит так же.
 * ПЛЮС: +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Количество операций меньше;
 * Скорость доступа к данным выше. 
 */

/**
 * Односвязный список - информация в текущем элементе храниться только о следующим.
 * Двусвязный список - информация в текущем элементе храниться о следующим и предыдущим.
 * Циклический односвязный список - если в односвязном списке есть информация, о том, что идет после 
 * последнего элемента и это будет первый элемент.
 * Двунаправленный циклический список - если в двусвязном списке есть информация, о том, что после 
 * последнего элемента идет первый и перед первым идет последний.
 */
/**
 * LinkedList нужен для небольшого количества элементов, в которых операции 
 * добавления\удаления встречаются чаще операций чтения.
 * Пример использования LinkedList: Ex001.java
 */

/**
 * Queue - коллекция.
 * Кто первый пришёл тот и будет первым обработан.
 * Пример использования Queue: Ex002.java
 * 
 * Queue<Integer> queue = new LinkedList<Integer>(); - Инициализация списка.
 * queue.add(1); - добавление в список.
 * int item = queue.remove(); - извлечение данных. Если не указывать индекс, 
 * то будет удален первый элемент списка.
 */

/**
 * Иерархия коллекции Queue
 * 
 *                Queue
 *               /     \
 *             |/       \|
 *           Deque      AbstractQueue
 *          /    |          \        
 *        |/    \|/          \|
 * LinkedList  ArrayDeque    PriorityQueue
 * 
 */
/**
 * PriorityQueue - это не классическая очередь, т.е. наивысший приоритет имеет «наименьший» элемент.
 * Пример использования: Ex000.java
 */

/**
 * Deque - это линейная коллекция, которая поддерживает вставку и удаление элементов на обоих концах.
 * Ссылка на документацию: https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html
 * Пример использования: Ex003.java
 */

/**
 * Stack - представляет собой обработку данных по принципу LIFO.
 * т.е. те данные, которые пришли ранее, будут обработаны в самую последнюю очередь.
 * Расширяет Vector пятью операциями, которые позволяют рассматривать вектор как стек.
 * 
 * push(E item)
 * pop()

 * Иерархия коллекции Stack:
 * 
 *             List
 *            /  |  \
 *           /   |   \       
 *         |/   \|/   \|
 * ArrayList   Vector  LinkedList
 *               |
 *              \|/
 *             Stack
 * 
 * Пример использования: 
 * Ex004.java
 * Ex005.java
 */
/**
 * Stack и Vector - устаревшие.
 * За место них лучше использовать коллекцию Deque.
 */

